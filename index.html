<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NERVA — Decision Integrity Layer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=DM+Sans:wght@300;400;500;600;700&display=swap" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
:root {
  --bg: #0a0a0c;
  --surface: #111114;
  --surface-2: #18181c;
  --border: #222228;
  --border-hover: #333340;
  --text: #e8e8ec;
  --text-dim: #7a7a88;
  --text-muted: #4a4a55;
  --accent: #00ff88;
  --accent-dim: #00cc6a;
  --accent-glow: rgba(0,255,136,0.08);
  --danger: #ff3355;
  --danger-dim: rgba(255,51,85,0.15);
  --warn: #ffaa00;
  --warn-dim: rgba(255,170,0,0.15);
  --commit: #00ff88;
  --wait: #ffaa00;
  --toxic: #ff3355;
  --mono: 'JetBrains Mono', monospace;
  --sans: 'DM Sans', sans-serif;
}

* { margin: 0; padding: 0; box-sizing: border-box; }
html { font-size: 14px; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--sans);
  line-height: 1.5;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
}

::-webkit-scrollbar { width: 4px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

/* ─── HEADER ─── */
.header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 100;
  padding: 0 2rem; height: 48px;
  display: flex; align-items: center; justify-content: space-between;
  background: rgba(10,10,12,0.85);
  backdrop-filter: blur(20px);
  border-bottom: 1px solid var(--border);
}

.logo { font-family: var(--mono); font-weight: 700; font-size: 0.85rem; letter-spacing: 0.15em; color: var(--accent); }
.logo span { color: var(--text-dim); font-weight: 400; }

.nav { display: flex; gap: 0; }

.nav-btn {
  background: none; border: none; color: var(--text-dim);
  font-family: var(--mono); font-size: 0.7rem; letter-spacing: 0.08em;
  text-transform: uppercase; padding: 0.5rem 1rem; cursor: pointer;
  transition: color 0.2s; position: relative;
}
.nav-btn:hover, .nav-btn.active { color: var(--text); }
.nav-btn.active::after {
  content: ''; position: absolute; bottom: -1px; left: 1rem; right: 1rem;
  height: 1px; background: var(--accent);
}

/* ─── VIEWS ─── */
.view { display: none; padding-top: 48px; min-height: 100vh; }
.view.active { display: block; }

/* ─── DEMO LAYOUT ─── */
.demo-layout {
  display: grid; grid-template-columns: 300px 1fr 320px;
  height: calc(100vh - 48px); gap: 0;
}

/* Left Panel */
.panel-left {
  border-right: 1px solid var(--border); padding: 1.25rem;
  overflow-y: auto; display: flex; flex-direction: column; gap: 0.75rem;
}

.panel-label {
  font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.15em;
  text-transform: uppercase; color: var(--text-muted); margin-bottom: 0.25rem;
}

/* ─── NL SCENARIO INPUT ─── */
.nl-input-box {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 0.6rem;
  transition: border-color 0.2s;
}

.nl-input-box:focus-within { border-color: var(--accent); }

.nl-textarea {
  width: 100%;
  background: none;
  border: none;
  color: var(--text);
  font-family: var(--sans);
  font-size: 0.78rem;
  line-height: 1.5;
  resize: none;
  outline: none;
  min-height: 52px;
  max-height: 100px;
}

.nl-textarea::placeholder { color: var(--text-muted); }

.nl-actions {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 0.4rem;
}

.nl-hint {
  font-size: 0.6rem;
  color: var(--text-muted);
  font-family: var(--mono);
}

.eval-btn {
  background: var(--accent);
  color: var(--bg);
  border: none;
  font-family: var(--mono);
  font-size: 0.65rem;
  font-weight: 600;
  letter-spacing: 0.08em;
  padding: 0.35rem 0.75rem;
  cursor: pointer;
  border-radius: 2px;
  transition: all 0.15s;
}

.eval-btn:hover { background: #33ffaa; }
.eval-btn:disabled { background: var(--border); color: var(--text-muted); cursor: default; }

.nl-extracted {
  font-size: 0.65rem;
  color: var(--text-dim);
  font-family: var(--mono);
  margin-top: 0.4rem;
  line-height: 1.4;
  display: none;
}

.nl-extracted.show { display: block; }

.nl-extracted .tag {
  display: inline-block;
  background: var(--accent-glow);
  border: 1px solid rgba(0,255,136,0.15);
  color: var(--accent);
  padding: 0.1rem 0.35rem;
  border-radius: 2px;
  margin: 0.15rem 0.15rem 0.15rem 0;
  font-size: 0.6rem;
}

/* Scenario Presets */
.presets { display: grid; grid-template-columns: 1fr 1fr; gap: 0.4rem; }

.preset-btn {
  background: var(--surface); border: 1px solid var(--border);
  color: var(--text-dim); font-family: var(--mono); font-size: 0.65rem;
  letter-spacing: 0.04em; padding: 0.45rem 0.4rem; cursor: pointer;
  transition: all 0.15s; border-radius: 2px; text-align: left; line-height: 1.3;
}
.preset-btn:hover { border-color: var(--accent); color: var(--text); background: var(--accent-glow); }
.preset-btn.active { border-color: var(--accent); color: var(--accent); background: var(--accent-glow); }
.preset-label { display: block; font-weight: 600; font-size: 0.7rem; }
.preset-sub { display: block; color: var(--text-muted); margin-top: 1px; }

/* Sliders */
.slider-group { display: flex; flex-direction: column; gap: 0.65rem; }
.slider-row { display: flex; flex-direction: column; gap: 0.25rem; }
.slider-header { display: flex; justify-content: space-between; align-items: baseline; }

.slider-name {
  font-family: var(--mono); font-size: 0.72rem; font-weight: 500; color: var(--text);
}

.slider-val {
  font-family: var(--mono); font-size: 0.72rem; color: var(--accent);
  font-weight: 600; min-width: 2.5rem; text-align: right;
}

.slider-desc { font-size: 0.6rem; color: var(--text-muted); line-height: 1.2; }

input[type="range"] {
  -webkit-appearance: none; width: 100%; height: 3px;
  background: var(--border); border-radius: 2px; outline: none; cursor: pointer;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%;
  background: var(--accent); border: 2px solid var(--bg);
  box-shadow: 0 0 8px rgba(0,255,136,0.3); cursor: pointer; transition: transform 0.1s;
}
input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
input[type="range"]::-webkit-slider-thumb:active { transform: scale(1.3); box-shadow: 0 0 16px rgba(0,255,136,0.5); }

input[type="range"].threshold-slider::-webkit-slider-thumb {
  background: var(--warn); box-shadow: 0 0 8px rgba(255,170,0,0.3);
}

input[type="range"]:disabled {
  opacity: 0.3;
  cursor: default;
}

.divider { height: 1px; background: var(--border); margin: 0.15rem 0; }

/* ─── TAU MODE SELECTOR ─── */
.tau-mode-section {
  display: flex;
  flex-direction: column;
  gap: 0.4rem;
}

.tau-mode-row {
  display: flex;
  gap: 0.3rem;
}

.tau-mode-btn {
  flex: 1;
  background: var(--surface);
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-family: var(--mono);
  font-size: 0.6rem;
  letter-spacing: 0.04em;
  padding: 0.35rem 0.2rem;
  cursor: pointer;
  transition: all 0.15s;
  border-radius: 2px;
  text-align: center;
}

.tau-mode-btn:hover { border-color: var(--border-hover); color: var(--text-dim); }
.tau-mode-btn.active { border-color: var(--warn); color: var(--warn); background: var(--warn-dim); }

.tau-auto-desc {
  font-size: 0.6rem;
  color: var(--text-muted);
  font-family: var(--mono);
  line-height: 1.4;
  padding: 0.3rem 0.4rem;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 2px;
}

.tau-auto-desc strong { color: var(--warn); }

.tau-slider-wrap {
  transition: opacity 0.2s;
}

.tau-slider-wrap.disabled {
  opacity: 0.35;
  pointer-events: none;
}

/* ─── CENTER — 3D VIEWPORT ─── */
.viewport { position: relative; background: var(--bg); overflow: hidden; }
#three-canvas { width: 100%; height: 100%; display: block; }

.decision-badge {
  position: absolute; top: 1.25rem; left: 50%; transform: translateX(-50%);
  font-family: var(--mono); font-weight: 700; font-size: 1rem; letter-spacing: 0.2em;
  padding: 0.4rem 1.5rem; border-radius: 2px; border: 1px solid;
  backdrop-filter: blur(10px); transition: all 0.3s; text-align: center;
}

.decision-badge.commit { color: var(--commit); border-color: var(--commit); background: rgba(0,255,136,0.08); box-shadow: 0 0 30px rgba(0,255,136,0.1); }
.decision-badge.wait { color: var(--wait); border-color: var(--wait); background: rgba(255,170,0,0.08); box-shadow: 0 0 30px rgba(255,170,0,0.1); }
.decision-badge.toxic { color: var(--toxic); border-color: var(--toxic); background: rgba(255,51,85,0.08); box-shadow: 0 0 30px rgba(255,51,85,0.1); animation: toxic-pulse 1.5s ease-in-out infinite; }
@keyframes toxic-pulse { 0%, 100% { box-shadow: 0 0 30px rgba(255,51,85,0.1); } 50% { box-shadow: 0 0 50px rgba(255,51,85,0.25); } }
.decision-sub { font-size: 0.55rem; font-weight: 400; letter-spacing: 0.1em; margin-top: 2px; opacity: 0.7; }

.viewport-stats {
  position: absolute; bottom: 1rem; left: 1rem; right: 1rem;
  display: flex; justify-content: center; gap: 2rem; pointer-events: none;
}
.vstat { text-align: center; }
.vstat-label { font-family: var(--mono); font-size: 0.55rem; letter-spacing: 0.12em; text-transform: uppercase; color: var(--text-muted); }
.vstat-value { font-family: var(--mono); font-size: 1.1rem; font-weight: 600; color: var(--text); }

/* ─── RIGHT PANEL ─── */
.panel-right { border-left: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }

.output-section {
  padding: 1.25rem; flex: 1; overflow-y: auto;
  display: flex; flex-direction: column; gap: 0.75rem;
}

.metrics-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }

.metric-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 2px; padding: 0.6rem 0.75rem;
}
.metric-label { font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.1em; text-transform: uppercase; color: var(--text-muted); }
.metric-value { font-family: var(--mono); font-size: 1.15rem; font-weight: 700; margin-top: 0.15rem; }
.metric-bar { height: 2px; background: var(--border); margin-top: 0.4rem; border-radius: 1px; overflow: hidden; }
.metric-bar-fill { height: 100%; border-radius: 1px; transition: width 0.3s ease, background 0.3s ease; }

/* ─── EXPLANATION PANEL WITH TOGGLE ─── */
.explain-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.explain-toggle {
  display: flex;
  gap: 0;
  border: 1px solid var(--border);
  border-radius: 2px;
  overflow: hidden;
}

.explain-toggle-btn {
  background: none;
  border: none;
  color: var(--text-muted);
  font-family: var(--mono);
  font-size: 0.55rem;
  letter-spacing: 0.06em;
  padding: 0.2rem 0.5rem;
  cursor: pointer;
  transition: all 0.15s;
}

.explain-toggle-btn:first-child { border-right: 1px solid var(--border); }
.explain-toggle-btn:hover { color: var(--text-dim); }
.explain-toggle-btn.active { background: var(--accent-glow); color: var(--accent); }

.nl-explanation {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 2px; padding: 0.75rem;
  font-size: 0.78rem; line-height: 1.55; color: var(--text-dim);
}
.nl-explanation strong { color: var(--text); }

/* ─── API + LLM PANELS ─── */
.api-section { border-top: 1px solid var(--border); padding: 0.75rem 1.25rem; background: var(--surface); }
.api-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
.api-label { font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.15em; text-transform: uppercase; color: var(--text-muted); }

.copy-btn {
  background: none; border: 1px solid var(--border); color: var(--text-dim);
  font-family: var(--mono); font-size: 0.6rem; padding: 0.2rem 0.5rem;
  cursor: pointer; border-radius: 2px; transition: all 0.15s;
}
.copy-btn:hover { border-color: var(--accent); color: var(--accent); }

.api-output {
  font-family: var(--mono); font-size: 0.65rem; line-height: 1.6; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 2px;
  padding: 0.6rem; overflow-x: auto; white-space: pre; max-height: 200px; overflow-y: auto;
}
.api-output .key { color: var(--accent-dim); }
.api-output .string { color: #88aaff; }
.api-output .number { color: var(--warn); }

.llm-panel { border-top: 1px solid var(--border); background: var(--surface); }

.llm-toggle {
  width: 100%; display: flex; align-items: center; justify-content: space-between;
  padding: 0.5rem 1.25rem; background: none; border: none; color: var(--text-dim);
  font-family: var(--mono); font-size: 0.6rem; letter-spacing: 0.12em;
  text-transform: uppercase; cursor: pointer; transition: color 0.15s;
}
.llm-toggle:hover { color: var(--text); }
.llm-toggle .arrow { transition: transform 0.2s; font-size: 0.7rem; }
.llm-toggle.open .arrow { transform: rotate(180deg); }

.llm-content { display: none; padding: 0 1.25rem 0.75rem; }
.llm-content.open { display: block; }

.llm-schema {
  font-family: var(--mono); font-size: 0.6rem; line-height: 1.6; color: var(--text-dim);
  background: var(--bg); border: 1px solid var(--border); border-radius: 2px;
  padding: 0.6rem; overflow-x: auto; white-space: pre; max-height: 180px; overflow-y: auto;
}

.llm-note { font-size: 0.65rem; color: var(--text-muted); margin-top: 0.4rem; line-height: 1.4; }

/* ─── PITCH VIEW ─── */
.pitch-container { max-width: 780px; margin: 0 auto; padding: 3rem 2rem 4rem; }

.pitch-hero { text-align: center; padding: 4rem 0 3rem; border-bottom: 1px solid var(--border); margin-bottom: 3rem; }
.pitch-hero h1 { font-family: var(--mono); font-size: 2.2rem; font-weight: 700; letter-spacing: 0.08em; color: var(--text); margin-bottom: 0.75rem; }
.pitch-hero .tagline { font-size: 1.1rem; color: var(--accent); font-weight: 400; margin-bottom: 0.5rem; }
.pitch-hero .sub { color: var(--text-muted); font-size: 0.85rem; }

.pitch-section { margin-bottom: 2.5rem; }
.pitch-section h2 { font-family: var(--mono); font-size: 0.7rem; letter-spacing: 0.2em; text-transform: uppercase; color: var(--accent); margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
.pitch-section p { color: var(--text-dim); font-size: 0.9rem; line-height: 1.7; margin-bottom: 0.75rem; }
.pitch-section p strong { color: var(--text); }

.pitch-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; margin-top: 1rem; }
.pitch-card { background: var(--surface); border: 1px solid var(--border); border-radius: 2px; padding: 1rem; }
.pitch-card h3 { font-family: var(--mono); font-size: 0.75rem; font-weight: 600; color: var(--text); margin-bottom: 0.3rem; }
.pitch-card p { font-size: 0.8rem; color: var(--text-dim); margin: 0; }

.pitch-code {
  font-family: var(--mono); font-size: 0.72rem; background: var(--surface);
  border: 1px solid var(--border); border-radius: 2px; padding: 1rem;
  color: var(--text-dim); overflow-x: auto; line-height: 1.7; margin-top: 1rem;
}

.pitch-flow { display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap; margin: 1rem 0; }
.flow-step { background: var(--surface); border: 1px solid var(--border); padding: 0.5rem 0.75rem; font-family: var(--mono); font-size: 0.7rem; color: var(--text); border-radius: 2px; }
.flow-arrow { color: var(--accent); font-family: var(--mono); font-size: 0.8rem; }

.pitch-footer { text-align: center; padding: 3rem 0 1rem; border-top: 1px solid var(--border); margin-top: 3rem; }
.pitch-footer .contact { font-family: var(--mono); font-size: 0.8rem; color: var(--text-dim); }
.pitch-footer a { color: var(--accent); text-decoration: none; }
.pitch-footer a:hover { text-decoration: underline; }
.pitch-footer .copy-line { font-size: 0.65rem; color: var(--text-muted); margin-top: 1rem; }

/* ─── API DOCS VIEW ─── */
.api-docs-container { max-width: 780px; margin: 0 auto; padding: 3rem 2rem 4rem; }
.api-docs-container h2 { font-family: var(--mono); font-size: 0.7rem; letter-spacing: 0.2em; text-transform: uppercase; color: var(--accent); margin-bottom: 1rem; margin-top: 2.5rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--border); }
.api-docs-container h2:first-child { margin-top: 2rem; }
.api-docs-container p { color: var(--text-dim); font-size: 0.88rem; line-height: 1.7; margin-bottom: 0.75rem; }
.api-docs-container code { font-family: var(--mono); font-size: 0.78rem; background: var(--surface); padding: 0.15rem 0.4rem; border-radius: 2px; color: var(--accent); }

/* ─── RESPONSIVE ─── */
@media (max-width: 1100px) { .demo-layout { grid-template-columns: 260px 1fr 280px; } }
@media (max-width: 860px) {
  .demo-layout { grid-template-columns: 1fr; grid-template-rows: auto 50vh auto; height: auto; min-height: 100vh; }
  .panel-left { border-right: none; border-bottom: 1px solid var(--border); }
  .viewport { min-height: 50vh; }
  .panel-right { border-left: none; border-top: 1px solid var(--border); }
}
</style>
<script defer src="/_vercel/insights/script.js"></script>
</head>
<body>

<!-- HEADER -->
<div class="header">
  <div class="logo">NERVA <span>/ Phasewell Research</span></div>
  <nav class="nav">
    <button class="nav-btn active" data-view="demo">Demo</button>
    <button class="nav-btn" data-view="pitch">Pitch</button>
    <button class="nav-btn" data-view="api-docs">API</button>
  </nav>
</div>

<!-- ═══════════ DEMO VIEW ═══════════ -->
<div class="view active" id="view-demo">
  <div class="demo-layout">

    <!-- LEFT PANEL -->
    <div class="panel-left">

      <!-- NL SCENARIO INPUT -->
      <div>
        <div class="panel-label">Describe Scenario</div>
        <div class="nl-input-box">
          <textarea class="nl-textarea" id="nl-input" placeholder="e.g. &quot;Drone approaching target, intel is weak, weather unstable, ROE requires high confidence...&quot;"></textarea>
          <div class="nl-actions">
            <span class="nl-hint">or use presets ↓</span>
            <button class="eval-btn" id="eval-btn">Evaluate</button>
          </div>
        </div>
        <div class="nl-extracted" id="nl-extracted"></div>
      </div>

      <div class="divider"></div>

      <!-- PRESETS -->
      <div>
        <div class="panel-label">Scenarios</div>
        <div class="presets">
          <button class="preset-btn" data-preset="drone">
            <span class="preset-label">Drone ROE</span>
            <span class="preset-sub">Uncertain intel</span>
          </button>
          <button class="preset-btn" data-preset="hft">
            <span class="preset-label">HFT Trade</span>
            <span class="preset-sub">Volatile market</span>
          </button>
          <button class="preset-btn" data-preset="av">
            <span class="preset-label">AV Lane</span>
            <span class="preset-sub">Pedestrian near</span>
          </button>
          <button class="preset-btn" data-preset="surgical">
            <span class="preset-label">Surgical</span>
            <span class="preset-sub">Patient anomaly</span>
          </button>
        </div>
      </div>

      <div class="divider"></div>

      <!-- INPUT SLIDERS -->
      <div>
        <div class="panel-label">Input Parameters</div>
        <div class="slider-group">
          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-name">E — Urgency</span>
              <span class="slider-val" id="val-e">0.50</span>
            </div>
            <input type="range" id="sl-e" min="0" max="1" step="0.01" value="0.50">
            <div class="slider-desc">Priority / emotional weight</div>
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-name">S — Strategy</span>
              <span class="slider-val" id="val-s">0.60</span>
            </div>
            <input type="range" id="sl-s" min="0" max="1" step="0.01" value="0.60">
            <div class="slider-desc">Plan quality / coherence</div>
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-name">R — Risk</span>
              <span class="slider-val" id="val-r">0.40</span>
            </div>
            <input type="range" id="sl-r" min="0" max="1" step="0.01" value="0.40">
            <div class="slider-desc">Exposure to negative outcomes</div>
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-name">Support</span>
              <span class="slider-val" id="val-sup">0.75</span>
            </div>
            <input type="range" id="sl-sup" min="0" max="1" step="0.01" value="0.75">
            <div class="slider-desc">Data confidence / evidence</div>
          </div>
          <div class="slider-row">
            <div class="slider-header">
              <span class="slider-name">Stability</span>
              <span class="slider-val" id="val-stab">0.70</span>
            </div>
            <input type="range" id="sl-stab" min="0" max="1" step="0.01" value="0.70">
            <div class="slider-desc">System health / environment</div>
          </div>
        </div>
      </div>

      <div class="divider"></div>

      <!-- TAU / THRESHOLD -->
      <div class="tau-mode-section">
        <div class="panel-label">τ — Commitment Threshold</div>
        <div class="tau-mode-row">
          <button class="tau-mode-btn active" data-tau="auto">Auto</button>
          <button class="tau-mode-btn" data-tau="low">Low</button>
          <button class="tau-mode-btn" data-tau="med">Med</button>
          <button class="tau-mode-btn" data-tau="high">High</button>
          <button class="tau-mode-btn" data-tau="manual">Manual</button>
        </div>
        <div class="tau-auto-desc" id="tau-desc">
          <strong>Auto:</strong> τ computed from risk, stability, and reversibility. Two-way doors get low barriers; one-way doors get high ones.
        </div>
        <div class="tau-slider-wrap disabled" id="tau-slider-wrap">
          <div class="slider-row" style="margin-top:0.4rem;">
            <div class="slider-header">
              <span class="slider-name">τ Manual</span>
              <span class="slider-val" id="val-tau" style="color:var(--warn);">0.50</span>
            </div>
            <input type="range" class="threshold-slider" id="sl-tau" min="0.05" max="1" step="0.01" value="0.50">
          </div>
        </div>
      </div>

    </div>

    <!-- CENTER — 3D VIEWPORT -->
    <div class="viewport">
      <canvas id="three-canvas"></canvas>
      <div class="decision-badge commit" id="decision-badge">
        <div id="decision-text">COMMIT</div>
        <div class="decision-sub" id="decision-sub">Bold Opportunity</div>
      </div>
      <div class="viewport-stats">
        <div class="vstat">
          <div class="vstat-label">|r|</div>
          <div class="vstat-value" id="vstat-r">0.00</div>
        </div>
        <div class="vstat">
          <div class="vstat-label">θ</div>
          <div class="vstat-value" id="vstat-theta">0.00</div>
        </div>
        <div class="vstat">
          <div class="vstat-label">φ</div>
          <div class="vstat-value" id="vstat-phi">0.00</div>
        </div>
        <div class="vstat">
          <div class="vstat-label">τ</div>
          <div class="vstat-value" id="vstat-tau" style="color:var(--warn)">0.50</div>
        </div>
        <div class="vstat">
          <div class="vstat-label">EV</div>
          <div class="vstat-value" id="vstat-ev">0.00</div>
        </div>
      </div>
    </div>

    <!-- RIGHT PANEL -->
    <div class="panel-right">
      <div class="output-section">
        <div>
          <div class="panel-label">Decision Metrics</div>
          <div class="metrics-grid">
            <div class="metric-card">
              <div class="metric-label">Integrity</div>
              <div class="metric-value" id="m-integrity" style="color:var(--accent);">0.72</div>
              <div class="metric-bar"><div class="metric-bar-fill" id="bar-integrity" style="width:72%;background:var(--accent);"></div></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Coherence</div>
              <div class="metric-value" id="m-coherence" style="color:var(--accent);">0.85</div>
              <div class="metric-bar"><div class="metric-bar-fill" id="bar-coherence" style="width:85%;background:var(--accent);"></div></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Purity</div>
              <div class="metric-value" id="m-purity">0.85</div>
              <div class="metric-bar"><div class="metric-bar-fill" id="bar-purity" style="width:85%;background:var(--text-dim);"></div></div>
            </div>
            <div class="metric-card">
              <div class="metric-label">Entropy</div>
              <div class="metric-value" id="m-entropy">0.23</div>
              <div class="metric-bar"><div class="metric-bar-fill" id="bar-entropy" style="width:23%;background:var(--text-dim);"></div></div>
            </div>
          </div>
        </div>

        <!-- EXPLANATION WITH TOGGLE -->
        <div>
          <div class="explain-header">
            <div class="panel-label" style="margin-bottom:0">Assessment</div>
            <div class="explain-toggle">
              <button class="explain-toggle-btn active" data-mode="human">Why?</button>
              <button class="explain-toggle-btn" data-mode="analyst">Analyst</button>
            </div>
          </div>
          <div class="nl-explanation" id="nl-explanation" style="margin-top:0.4rem;"></div>
        </div>
      </div>

      <!-- LLM Integration -->
      <div class="llm-panel">
        <button class="llm-toggle" id="llm-toggle">
          <span>LLM Integration Schema</span>
          <span class="arrow">▼</span>
        </button>
        <div class="llm-content" id="llm-content">
          <div class="llm-schema" id="llm-schema"></div>
          <div class="llm-note">Structured JSON for LLM tool-use / function-calling. Pass as tool output to any model.</div>
        </div>
      </div>

      <!-- API Output -->
      <div class="api-section">
        <div class="api-header">
          <span class="api-label">API Response</span>
          <button class="copy-btn" id="copy-btn">Copy</button>
        </div>
        <div class="api-output" id="api-output"></div>
      </div>
    </div>

  </div>
</div>

<!-- ═══════════ PITCH VIEW ═══════════ -->
<div class="view" id="view-pitch">
  <div class="pitch-container">
    <div class="pitch-hero">
      <h1>NERVA</h1>
      <div class="tagline">AI That Knows When NOT to Act</div>
      <div class="sub">Fast, explainable decision integrity for autonomous systems</div>
    </div>

    <div class="pitch-section">
      <h2>Problem</h2>
      <p>Autonomous systems optimize for outcomes without moral reasoning. Drones, trading bots, self-driving cars, surgical robots — they do what the math says. When the math is wrong, the consequences are catastrophic and unexplainable.</p>
      <p>Current guardrails are either <strong>too slow</strong> for real-time systems or <strong>too opaque</strong> for regulatory audit. The market needs both speed and mathematical provenance.</p>
    </div>

    <div class="pitch-section">
      <h2>Solution</h2>
      <p>NERVA is a <strong>decision integrity layer</strong> — a safety filter that validates autonomous actions before execution using information-theoretic formalism.</p>
      <div class="pitch-flow">
        <div class="flow-step">System proposes action</div>
        <span class="flow-arrow">→</span>
        <div class="flow-step">6D state → 3D projection</div>
        <span class="flow-arrow">→</span>
        <div class="flow-step">COMMIT | WAIT | TOXIC</div>
        <span class="flow-arrow">→</span>
        <div class="flow-step">Full audit trail</div>
      </div>
      <p>Domain-agnostic. Same math for drones, trading engines, AVs, and surgical robots. Designed for <strong>sub-10ms latency</strong> with complete mathematical provenance on every decision.</p>
    </div>

    <div class="pitch-section">
      <h2>How It Works</h2>
      <p>Six input dimensions — urgency, strategy quality, risk exposure, data confidence, system stability, and an <strong>automatically computed commitment threshold</strong> — are projected onto a Bloch sphere representation using density matrix formalism from quantum information theory.</p>
      <p>The threshold (τ) uses a <strong>one-way door / two-way door</strong> framework: irreversible, high-stakes decisions automatically raise the bar for commitment. Reversible, low-stakes decisions lower it. This maps Bezos-style decision philosophy to mathematical constraints.</p>
      <p>This isn't quantum computing. It's using the <strong>mathematical elegance of quantum information theory</strong> (Nielsen & Chuang) to represent decision uncertainty in bounded dimensions. The formalism gives us coherence metrics, entropy measures, and purity scores — all with closed-form solutions at negligible computational cost.</p>
      <div class="pitch-code">COMMIT    if |r| ≥ τ  AND  EV > 0  AND  Integrity ≥ 0.5
WAIT      if |r| < τ
TOXIC     if |r| ≥ τ  BUT  (EV ≤ 0  OR  Integrity < 0.5)

τ_auto = base × (1 + risk_weight) × (1 - reversibility)
         where reversibility = f(stability, support)</div>
    </div>

    <div class="pitch-section">
      <h2>Market Timing</h2>
      <p><strong>EU AI Act</strong> compliance deadlines hit Q2 2026. <strong>DoD ethical AI mandates</strong> are tightening oversight on autonomous weapons. <strong>SEC/CFTC</strong> are increasing HFT guardrail requirements. <strong>AV liability law</strong> demands explainable ethical triage. The regulatory forcing functions are real and imminent.</p>
    </div>

    <div class="pitch-section">
      <h2>Target Markets</h2>
      <div class="pitch-grid">
        <div class="pitch-card">
          <h3>Defense & Aerospace</h3>
          <p>Autonomous targeting, ROE compliance, kill-chain validation</p>
        </div>
        <div class="pitch-card">
          <h3>Financial Trading</h3>
          <p>HFT guardrails, risk limits, flash-crash prevention</p>
        </div>
        <div class="pitch-card">
          <h3>Autonomous Vehicles</h3>
          <p>Split-second ethical triage, liability audit trails</p>
        </div>
        <div class="pitch-card">
          <h3>Medical Robotics</h3>
          <p>Surgical decision support, patient safety validation</p>
        </div>
      </div>
      <p style="margin-top:1rem;">Initial focus: <strong>defense tech</strong> and <strong>financial services</strong> — sectors with immediate regulatory drivers and high willingness to pay.</p>
    </div>

    <div class="pitch-section">
      <h2>Competitive Edge</h2>
      <p><strong>Mathematical foundation</strong> from quantum information theory — not heuristics. <strong>Domain agnostic</strong> — same framework across verticals. <strong>Real-time by design</strong> — closed-form solutions, no neural network inference. <strong>Explainability native</strong> — every decision carries full mathematical provenance. <strong>LLM-ready architecture</strong> — structured JSON output designed for tool-use integration with any foundation model.</p>
    </div>

    <div class="pitch-section">
      <h2>Roadmap</h2>
      <p><strong>Now:</strong> Framework validation, shadow-mode pilots with design partners in defense and fintech. Benchmark harness development. Red-team stress testing.</p>
      <p><strong>Next:</strong> Production API. LLM integration layer. Enterprise sales. Conference presence.</p>
      <p><strong>Seeking:</strong> $3M seed to accelerate validation, hire core engineering team, and launch first paid pilots.</p>
    </div>

    <div class="pitch-footer">
      <div class="copy-line">NERVA INTEGRITY LAYER · Starpoint LLC · Confidential © 2026</div>
    </div>
  </div>
</div>

<!-- ═══════════ API DOCS VIEW ═══════════ -->
<div class="view" id="view-api-docs">
  <div class="api-docs-container">
    <h2>Endpoint</h2>
    <p><code>POST /v1/validate</code></p>
    <p>Validates a proposed action against NERVA's integrity framework. Returns a decision state with full mathematical provenance.</p>

    <h2>Request Body</h2>
    <div class="pitch-code">{
  "emotion": 0.50,
  "strategy": 0.60,
  "risk": 0.40,
  "support": 0.75,
  "stability": 0.70,
  "threshold": "auto",        // "auto" | number (0-1)
  "context": "drone_targeting" // optional domain tag
}</div>

    <h2>Response</h2>
    <div class="pitch-code">{
  "decision": "COMMIT",
  "quadrant": "bold_opportunity",
  "integrity": 0.72,
  "expected_value": 0.43,
  "coherence": 0.85,
  "purity": 0.87,
  "entropy": 0.20,
  "threshold_used": 0.52,
  "threshold_mode": "auto",
  "bloch": { "theta": 0.84, "phi": 0.35, "r": 1.22 },
  "reasoning": "Situation shows strong support for this action.
    Risk is present but manageable given the evidence available.
    This is a reversible decision — proceed with monitoring.",
  "reasoning_analyst": "Integrity 0.72, EV +0.43, coherence 0.85.
    Threshold met (r=1.22 > τ=0.52). Positive EV. Proceed."
}</div>

    <h2>Threshold Modes</h2>
    <div class="pitch-code">threshold: "auto"   → computed from risk, stability, reversibility
threshold: 0.65    → manual override (advanced / domain-tuned)

Auto logic:
  reversibility = (support + stability) / 2
  base = 0.30
  τ = base + (risk × 0.5) - (reversibility × 0.25)
  clamped to [0.15, 0.85]

Intuition:
  One-way door (low reversibility, high risk) → τ ≈ 0.70–0.85
  Two-way door (high reversibility, low risk)  → τ ≈ 0.15–0.35</div>

    <h2>LLM Tool-Use Integration</h2>
    <p>NERVA's output is designed as a <strong>tool response</strong> for LLM function-calling. The structured JSON can be passed directly to any foundation model as a tool result.</p>
    <div class="pitch-code">{
  "name": "nerva_validate",
  "description": "Validate a proposed action against NERVA integrity layer",
  "parameters": {
    "type": "object",
    "properties": {
      "emotion":   { "type": "number", "min": 0, "max": 1 },
      "strategy":  { "type": "number", "min": 0, "max": 1 },
      "risk":      { "type": "number", "min": 0, "max": 1 },
      "support":   { "type": "number", "min": 0, "max": 1 },
      "stability": { "type": "number", "min": 0, "max": 1 },
      "threshold": { "oneOf": [
        { "type": "string", "enum": ["auto"] },
        { "type": "number", "min": 0, "max": 1 }
      ]}
    },
    "required": ["emotion","strategy","risk","support","stability"]
  }
}</div>
    <p>The LLM proposes an action → extracts domain context into NERVA's 6 dimensions → receives a structured decision with both human-readable and analyst-grade reasoning → acts accordingly or escalates to human review.</p>

    <h2>Natural Language Input (Beta)</h2>
    <p>NERVA accepts free-text scenario descriptions via an extraction layer. The extractor maps natural language to the 6D input space using keyword and semantic analysis. In production, this layer will be powered by LLM function-calling for richer context extraction.</p>
    <div class="pitch-code">POST /v1/validate/nl
{
  "scenario": "Drone approaching target zone. Intel confidence
    is low — only satellite imagery, no HUMINT. Weather
    deteriorating. ROE requires high certainty before engagement.",
  "domain": "defense"
}

→ Extracted: E=0.80, S=0.40, R=0.85, Sup=0.35, Stab=0.45
→ Auto τ: 0.72 (one-way door — lethal, irreversible)
→ Decision: WAIT</div>

    <h2>Decision Logic</h2>
    <p><code>COMMIT</code> — Radius meets threshold, positive expected value, integrity above 0.5. Safe to proceed.</p>
    <p><code>WAIT</code> — Radius below threshold. Insufficient signal. Hold for more data.</p>
    <p><code>TOXIC_ESCALATION</code> — Sufficient signal but negative EV or low integrity. Block and escalate.</p>

    <h2>Mathematical Basis</h2>
    <p>Decision coordinates: <code>x = E + S</code> (intent), <code>y = R</code> (risk), <code>z = Support × Stability</code> (integrity). Projected to Bloch sphere via <code>θ = acos(z/|r|)</code>, <code>φ = atan2(y,x)</code>. Density matrix <code>ρ̂ = |ψ⟩⟨ψ|</code> yields coherence via l₁-norm and entropy via von Neumann formula. All closed-form, O(1) computation.</p>
  </div>
</div>

<script>
// ═══════════════════════════════════════
//  NERVA v8.1 ENGINE
// ═══════════════════════════════════════

const NERVA = {
  // ─── AUTO THRESHOLD ───
  // Bezos one-way / two-way door logic
  computeAutoTau(r, sup, stab) {
    const reversibility = (sup + stab) / 2;  // high support + stability = more reversible
    const base = 0.30;
    let tau = base + (r * 0.5) - (reversibility * 0.25);
    return Math.max(0.15, Math.min(0.85, tau));
  },

  compute(e, s, r, sup, stab, tau) {
    const x = e + s;
    const y = r;
    const z = sup * stab;
    const radius = Math.sqrt(x*x + y*y + z*z);
    const theta = radius > 0 ? Math.acos(Math.min(1, z / radius)) : 0;
    const phi = Math.atan2(y, x);

    const intent = (e + s) / 2;
    const ev = (intent - r) * z;
    const integrity = z / Math.max(radius, 0.001);
    const coherence = Math.exp(-0.5 * Math.abs(phi));

    const cosH = Math.cos(theta / 2);
    const sinH = Math.sin(theta / 2);
    const rho00 = cosH * cosH;
    const rho11 = sinH * sinH;
    const offDiag = cosH * sinH;
    const purity = rho00*rho00 + rho11*rho11 + 2*offDiag*offDiag;

    let entropy = 0;
    if (rho00 > 0.001 && rho00 < 0.999) {
      entropy = -(rho00 * Math.log2(rho00) + rho11 * Math.log2(rho11));
    }

    let decision;
    if (radius < tau) {
      decision = 'WAIT';
    } else if (ev <= 0 || integrity < 0.5) {
      decision = 'TOXIC_ESCALATION';
    } else {
      decision = 'COMMIT';
    }

    let quadrant;
    if (x >= 0.5 && r >= 0.5) quadrant = 'bold_opportunity';
    else if (x >= 0.5 && r < 0.5) quadrant = 'clean_gain';
    else if (x < 0.5 && r >= 0.5) quadrant = 'chaotic_risk';
    else quadrant = 'low_signal';

    const quadrantLabels = { bold_opportunity: 'Bold Opportunity', clean_gain: 'Clean Gain', chaotic_risk: 'Chaotic Risk', low_signal: 'Low Signal' };

    // Reversibility score for explanation
    const reversibility = (sup + stab) / 2;

    return {
      decision, quadrant, quadrantLabel: quadrantLabels[quadrant],
      x, y, z, radius, theta, phi,
      ev, integrity, coherence, purity, entropy, reversibility,
      tau,
      input: { emotion: e, strategy: s, risk: r, support: sup, stability: stab, threshold: tau }
    };
  },

  // ─── ANALYST EXPLAINER (v8 original) ───
  explainAnalyst(result) {
    const { decision, integrity, ev, coherence, quadrantLabel, tau, radius } = result;
    if (decision === 'COMMIT') {
      const strength = integrity > 0.7 ? 'strong' : 'adequate';
      return `Decision state shows <strong>${strength} alignment</strong> between intent and support (integrity ${(integrity*100).toFixed(0)}%). EV +${ev.toFixed(2)}. Coherence ${(coherence*100).toFixed(0)}%. Radius ${radius.toFixed(2)} exceeds τ ${tau.toFixed(2)}. <strong>Proceed with monitoring.</strong>`;
    } else if (decision === 'WAIT') {
      return `Signal radius ${radius.toFixed(2)} below threshold τ=${tau.toFixed(2)}. <strong>Insufficient signal strength</strong> for commitment. ${quadrantLabel} quadrant. EV ${ev >= 0 ? '+' : ''}${ev.toFixed(2)}. <strong>Gather more data.</strong>`;
    } else {
      const reason = integrity < 0.5 ? `low integrity (${(integrity*100).toFixed(0)}%)` : `negative EV (${ev.toFixed(2)})`;
      return `<strong>Action blocked.</strong> Signal present (r=${radius.toFixed(2)} ≥ τ=${tau.toFixed(2)}) but ${reason}. ${quadrantLabel}. <strong>Escalate to human review.</strong>`;
    }
  },

  // ─── HUMAN EXPLAINER (no math vocabulary) ───
  explainHuman(result) {
    const { decision, input, reversibility } = result;
    const { emotion: e, strategy: s, risk: r, support: sup, stability: stab } = input;

    // Build situation descriptors
    const urgencyDesc = e > 0.7 ? 'high urgency' : e > 0.4 ? 'moderate urgency' : 'low urgency';
    const planDesc = s > 0.7 ? 'a solid plan' : s > 0.4 ? 'a reasonable plan' : 'a weak plan';
    const riskDesc = r > 0.7 ? 'The risk is significant' : r > 0.4 ? 'There is meaningful risk involved' : 'The risk level is low';
    const supportDesc = sup > 0.7 ? 'strong supporting evidence' : sup > 0.4 ? 'moderate evidence' : 'weak evidence';
    const stabilityDesc = stab > 0.7 ? 'stable conditions' : stab > 0.4 ? 'somewhat unstable conditions' : 'unstable conditions';
    const doorType = reversibility > 0.6 ? 'two-way door — this can be undone' : reversibility > 0.4 ? 'partially reversible' : 'one-way door — this cannot be easily undone';

    if (decision === 'COMMIT') {
      return `This situation has <strong>${urgencyDesc}</strong> with <strong>${planDesc}</strong> behind it. ${riskDesc}, but there's <strong>${supportDesc}</strong> and <strong>${stabilityDesc}</strong>. This looks like a <strong>${doorType}</strong>. <strong>NERVA recommends proceeding</strong>, with continued monitoring.`;
    } else if (decision === 'WAIT') {
      // What would change it
      let changeHint = '';
      if (sup < 0.5) changeHint = 'Getting better data or confirmation would help the most.';
      else if (stab < 0.5) changeHint = 'Waiting for conditions to stabilize would strengthen the case.';
      else if (s < 0.5) changeHint = 'A clearer plan would make this more actionable.';
      else changeHint = 'More time or better conditions could shift this toward action.';

      return `There's <strong>${urgencyDesc}</strong> and <strong>${planDesc}</strong>, but the picture isn't complete enough to commit. ${riskDesc} under <strong>${stabilityDesc}</strong>, with <strong>${supportDesc}</strong>. This looks like a <strong>${doorType}</strong>. <strong>NERVA recommends waiting.</strong> ${changeHint}`;
    } else {
      // TOXIC
      let dangerDesc = '';
      if (result.integrity < 0.5) {
        dangerDesc = 'The foundation for this action is weak — the supporting conditions don\'t justify the risk being taken.';
      } else {
        dangerDesc = 'The potential downside outweighs the upside, even though there\'s strong signal pushing toward action.';
      }
      return `This situation has <strong>${urgencyDesc}</strong>, but <strong>NERVA is blocking this action.</strong> ${dangerDesc} ${riskDesc} under <strong>${stabilityDesc}</strong>. This is a <strong>${doorType}</strong>. <strong>Escalate to a human decision-maker.</strong>`;
    }
  },

  toJSON(result, mode) {
    return {
      decision: result.decision,
      quadrant: result.quadrant,
      integrity: +result.integrity.toFixed(3),
      expected_value: +result.ev.toFixed(3),
      coherence: +result.coherence.toFixed(3),
      purity: +result.purity.toFixed(3),
      entropy: +result.entropy.toFixed(3),
      threshold_used: +result.tau.toFixed(3),
      threshold_mode: currentTauMode,
      bloch: { theta: +result.theta.toFixed(3), phi: +result.phi.toFixed(3), r: +result.radius.toFixed(3) },
      reasoning: NERVA.explainHuman(result).replace(/<[^>]+>/g, ''),
      reasoning_analyst: NERVA.explainAnalyst(result).replace(/<[^>]+>/g, '')
    };
  },

  toLLMSchema(result) {
    return {
      tool: "nerva_validate",
      input: result.input,
      output: NERVA.toJSON(result),
      meta: { version: "v8.1", latency_target_ms: 10, deterministic: true, threshold_mode: currentTauMode }
    };
  }
};


// ═══════════════════════════════════════
//  NL SCENARIO EXTRACTOR (client-side stub)
//  In production, this is an LLM call.
// ═══════════════════════════════════════

const NLExtractor = {
  extract(text) {
    const t = text.toLowerCase();
    const signals = {
      // Urgency
      urgency_high: /\b(urgent|immediate|critical|emergency|now|asap|time.?sensitive|life.?threatening)\b/,
      urgency_low: /\b(routine|planned|scheduled|non.?urgent|low.?priority)\b/,
      // Strategy
      strategy_high: /\b(planned|prepared|protocol|procedure|clear plan|well.?defined|systematic)\b/,
      strategy_low: /\b(improvise|uncertain plan|no plan|ad.?hoc|unplanned|chaotic)\b/,
      // Risk
      risk_high: /\b(lethal|fatal|catastroph|irreversible|explosive|high.?risk|dangerous|lives|casualties|crash)\b/,
      risk_med: /\b(risk|exposure|volatile|unstable|losses|downside)\b/,
      risk_low: /\b(safe|low.?risk|minimal.?risk|routine|reversible|no.?harm)\b/,
      // Support
      support_high: /\b(confirmed|verified|multiple.?sources|strong.?evidence|high.?confidence|clear.?data|reliable)\b/,
      support_low: /\b(uncertain|unconfirmed|weak.?intel|low.?confidence|sparse|no.?data|limited.?info|single.?source)\b/,
      // Stability
      stability_high: /\b(stable|calm|clear.?weather|normal.?operations|steady)\b/,
      stability_low: /\b(unstable|deteriorat|storm|degraded|failing|erratic|turbul|volatile.?market)\b/,
    };

    let e = 0.50, s = 0.50, r = 0.50, sup = 0.50, stab = 0.50;
    const tags = [];

    if (signals.urgency_high.test(t)) { e = 0.80 + Math.random()*0.15; tags.push('urgency:high'); }
    else if (signals.urgency_low.test(t)) { e = 0.15 + Math.random()*0.15; tags.push('urgency:low'); }

    if (signals.strategy_high.test(t)) { s = 0.70 + Math.random()*0.15; tags.push('strategy:high'); }
    else if (signals.strategy_low.test(t)) { s = 0.15 + Math.random()*0.2; tags.push('strategy:low'); }

    if (signals.risk_high.test(t)) { r = 0.80 + Math.random()*0.15; tags.push('risk:high'); }
    else if (signals.risk_med.test(t)) { r = 0.50 + Math.random()*0.2; tags.push('risk:med'); }
    else if (signals.risk_low.test(t)) { r = 0.10 + Math.random()*0.15; tags.push('risk:low'); }

    if (signals.support_high.test(t)) { sup = 0.75 + Math.random()*0.15; tags.push('evidence:strong'); }
    else if (signals.support_low.test(t)) { sup = 0.15 + Math.random()*0.2; tags.push('evidence:weak'); }

    if (signals.stability_high.test(t)) { stab = 0.70 + Math.random()*0.2; tags.push('conditions:stable'); }
    else if (signals.stability_low.test(t)) { stab = 0.15 + Math.random()*0.2; tags.push('conditions:unstable'); }

    // Clamp
    const clamp = v => Math.max(0, Math.min(1, +v.toFixed(2)));

    return {
      e: clamp(e), s: clamp(s), r: clamp(r), sup: clamp(sup), stab: clamp(stab),
      tags,
      confidence: tags.length >= 3 ? 'high' : tags.length >= 1 ? 'partial' : 'low'
    };
  }
};


// ═══════════════════════════════════════
//  PRESETS
// ═══════════════════════════════════════

const PRESETS = {
  drone:    { e: 0.80, s: 0.40, r: 0.85, sup: 0.35, stab: 0.60 },
  hft:      { e: 0.90, s: 0.75, r: 0.70, sup: 0.80, stab: 0.30 },
  av:       { e: 0.95, s: 0.50, r: 0.90, sup: 0.60, stab: 0.55 },
  surgical: { e: 0.30, s: 0.85, r: 0.60, sup: 0.90, stab: 0.80 }
};


// ═══════════════════════════════════════
//  STATE
// ═══════════════════════════════════════

let currentTauMode = 'auto';       // auto | low | med | high | manual
let currentExplainMode = 'human';  // human | analyst

const TAU_FIXED = { low: 0.25, med: 0.50, high: 0.75 };

const TAU_DESCRIPTIONS = {
  auto: '<strong>Auto:</strong> τ computed from risk, stability, and reversibility. Two-way doors get low barriers; one-way doors get high ones.',
  low: '<strong>Low barrier (0.25):</strong> Two-way door mode. Almost any signal is enough to commit. Use for easily reversible decisions.',
  med: '<strong>Medium barrier (0.50):</strong> Balanced. Requires moderate signal strength. Default for mixed-reversibility situations.',
  high: '<strong>High barrier (0.75):</strong> One-way door mode. Requires strong signal to commit. Use for irreversible, high-stakes decisions.',
  manual: '<strong>Manual:</strong> Set threshold directly with the slider. For domain experts tuning to specific operational requirements.'
};


// ═══════════════════════════════════════
//  DOM REFS
// ═══════════════════════════════════════

const sliders = {
  e: document.getElementById('sl-e'),
  s: document.getElementById('sl-s'),
  r: document.getElementById('sl-r'),
  sup: document.getElementById('sl-sup'),
  stab: document.getElementById('sl-stab'),
  tau: document.getElementById('sl-tau')
};

const vals = {
  e: document.getElementById('val-e'),
  s: document.getElementById('val-s'),
  r: document.getElementById('val-r'),
  sup: document.getElementById('val-sup'),
  stab: document.getElementById('val-stab'),
  tau: document.getElementById('val-tau')
};


// ═══════════════════════════════════════
//  RESOLVE TAU
// ═══════════════════════════════════════

function resolveTau() {
  const r = +sliders.r.value;
  const sup = +sliders.sup.value;
  const stab = +sliders.stab.value;

  if (currentTauMode === 'auto') {
    const tau = NERVA.computeAutoTau(r, sup, stab);
    sliders.tau.value = tau;
    vals.tau.textContent = tau.toFixed(2);
    return tau;
  } else if (currentTauMode === 'manual') {
    const tau = +sliders.tau.value;
    vals.tau.textContent = tau.toFixed(2);
    return tau;
  } else {
    const tau = TAU_FIXED[currentTauMode];
    sliders.tau.value = tau;
    vals.tau.textContent = tau.toFixed(2);
    return tau;
  }
}


// ═══════════════════════════════════════
//  THREE.JS
// ═══════════════════════════════════════

let scene, camera, renderer, decisionPoint, thresholdSphere;
let trailPoints = [];
let trailLine;
const MAX_TRAIL = 80;

function initThree() {
  const canvas = document.getElementById('three-canvas');
  const container = canvas.parentElement;

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0a0c);

  camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
  camera.position.set(2.2, 1.8, 2.2);
  camera.lookAt(0, 0, 0);

  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  scene.add(new THREE.GridHelper(4, 20, 0x222228, 0x161619));

  const axMat = new THREE.LineBasicMaterial({ color: 0x333340 });
  [[[0,0,0],[2.5,0,0]], [[0,0,0],[0,2.5,0]], [[0,0,0],[0,0,2.5]]].forEach(pts => {
    const g = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(...p)));
    scene.add(new THREE.Line(g, axMat));
  });

  const makeLabel = (text, pos) => {
    const c = document.createElement('canvas');
    c.width = 64; c.height = 32;
    const ctx = c.getContext('2d');
    ctx.font = '20px monospace';
    ctx.fillStyle = '#4a4a55';
    ctx.textAlign = 'center';
    ctx.fillText(text, 32, 22);
    const tex = new THREE.CanvasTexture(c);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const s = new THREE.Sprite(mat);
    s.position.set(...pos);
    s.scale.set(0.4, 0.2, 1);
    scene.add(s);
  };
  makeLabel('Intent', [2.7, 0, 0]);
  makeLabel('Risk', [0, 0, 2.7]);
  makeLabel('Integrity', [0, 2.7, 0]);

  const threshGeo = new THREE.SphereGeometry(0.5, 24, 16);
  const threshMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, wireframe: true, transparent: true, opacity: 0.08 });
  thresholdSphere = new THREE.Mesh(threshGeo, threshMat);
  scene.add(thresholdSphere);

  const pointGeo = new THREE.SphereGeometry(0.06, 16, 16);
  const pointMat = new THREE.MeshBasicMaterial({ color: 0x00ff88 });
  decisionPoint = new THREE.Mesh(pointGeo, pointMat);
  scene.add(decisionPoint);

  const glowGeo = new THREE.SphereGeometry(0.12, 16, 16);
  const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.15 });
  decisionPoint.add(new THREE.Mesh(glowGeo, glowMat));

  trailLine = new THREE.Line(
    new THREE.BufferGeometry(),
    new THREE.LineBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.3 })
  );
  scene.add(trailLine);
  scene.add(new THREE.AmbientLight(0xffffff, 0.5));

  // Camera controls
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };
  let cameraAngle = { h: Math.PI / 4, v: Math.PI / 6 };
  let cameraDistance = 3.5;

  container.addEventListener('mousedown', (e) => { isDragging = true; dragStart = { x: e.clientX, y: e.clientY }; });
  container.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    cameraAngle.h += (e.clientX - dragStart.x) * 0.005;
    cameraAngle.v = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngle.v + (e.clientY - dragStart.y) * 0.005));
    dragStart = { x: e.clientX, y: e.clientY };
  });
  container.addEventListener('mouseup', () => isDragging = false);
  container.addEventListener('mouseleave', () => isDragging = false);
  container.addEventListener('wheel', (e) => { cameraDistance = Math.max(1.5, Math.min(8, cameraDistance + e.deltaY * 0.005)); e.preventDefault(); }, { passive: false });

  container.addEventListener('touchstart', (e) => { if (e.touches.length === 1) { isDragging = true; dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } }, { passive: true });
  container.addEventListener('touchmove', (e) => {
    if (!isDragging || e.touches.length !== 1) return;
    cameraAngle.h += (e.touches[0].clientX - dragStart.x) * 0.005;
    cameraAngle.v = Math.max(-Math.PI/3, Math.min(Math.PI/3, cameraAngle.v + (e.touches[0].clientY - dragStart.y) * 0.005));
    dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
  }, { passive: true });
  container.addEventListener('touchend', () => isDragging = false);

  function animate() {
    requestAnimationFrame(animate);
    if (!isDragging) cameraAngle.h += 0.002;
    camera.position.x = Math.cos(cameraAngle.h) * Math.cos(cameraAngle.v) * cameraDistance;
    camera.position.y = Math.sin(cameraAngle.v) * cameraDistance + 0.5;
    camera.position.z = Math.sin(cameraAngle.h) * Math.cos(cameraAngle.v) * cameraDistance;
    camera.lookAt(0, 0.3, 0);
    renderer.render(scene, camera);
  }
  animate();

  window.addEventListener('resize', () => {
    const w = container.clientWidth, h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
}


// ═══════════════════════════════════════
//  UPDATE LOOP
// ═══════════════════════════════════════

function update() {
  const e = +sliders.e.value;
  const s = +sliders.s.value;
  const r = +sliders.r.value;
  const sup = +sliders.sup.value;
  const stab = +sliders.stab.value;
  const tau = resolveTau();

  vals.e.textContent = e.toFixed(2);
  vals.s.textContent = s.toFixed(2);
  vals.r.textContent = r.toFixed(2);
  vals.sup.textContent = sup.toFixed(2);
  vals.stab.textContent = stab.toFixed(2);

  const result = NERVA.compute(e, s, r, sup, stab, tau);

  // 3D
  if (decisionPoint) {
    decisionPoint.position.set(result.x, result.z, result.y);
    const colors = { COMMIT: 0x00ff88, WAIT: 0xffaa00, TOXIC_ESCALATION: 0xff3355 };
    decisionPoint.material.color.setHex(colors[result.decision]);
    decisionPoint.children[0].material.color.setHex(colors[result.decision]);

    trailPoints.push(new THREE.Vector3(result.x, result.z, result.y));
    if (trailPoints.length > MAX_TRAIL) trailPoints.shift();
    trailLine.geometry.dispose();
    trailLine.geometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
    trailLine.material.color.setHex(colors[result.decision]);
  }

  if (thresholdSphere) thresholdSphere.scale.setScalar(tau * 2);

  // Badge
  const badge = document.getElementById('decision-badge');
  badge.className = 'decision-badge ' + (result.decision === 'COMMIT' ? 'commit' : result.decision === 'WAIT' ? 'wait' : 'toxic');
  document.getElementById('decision-text').textContent = result.decision.replace('_', ' ');
  document.getElementById('decision-sub').textContent = result.quadrantLabel;

  // Viewport stats
  document.getElementById('vstat-r').textContent = result.radius.toFixed(2);
  document.getElementById('vstat-theta').textContent = result.theta.toFixed(2);
  document.getElementById('vstat-phi').textContent = result.phi.toFixed(2);
  document.getElementById('vstat-tau').textContent = tau.toFixed(2);
  document.getElementById('vstat-ev').textContent = (result.ev >= 0 ? '+' : '') + result.ev.toFixed(2);
  document.getElementById('vstat-ev').style.color = result.ev >= 0 ? 'var(--accent)' : 'var(--danger)';

  // Metrics
  const setMetric = (id, barId, value, color) => {
    document.getElementById(id).textContent = value.toFixed(2);
    document.getElementById(id).style.color = color || 'var(--text)';
    document.getElementById(barId).style.width = (Math.min(1, Math.max(0, value)) * 100) + '%';
    document.getElementById(barId).style.background = color || 'var(--text-dim)';
  };
  setMetric('m-integrity', 'bar-integrity', result.integrity, result.integrity >= 0.5 ? 'var(--accent)' : 'var(--danger)');
  setMetric('m-coherence', 'bar-coherence', result.coherence, result.coherence >= 0.5 ? 'var(--accent)' : 'var(--warn)');
  setMetric('m-purity', 'bar-purity', result.purity);
  setMetric('m-entropy', 'bar-entropy', result.entropy);

  // Explanation (toggled) — prefer LLM explanation when available
  if (currentExplainMode === 'human' && llmExplanationCache && lastScenarioText) {
    document.getElementById('nl-explanation').innerHTML = `<strong style="color:var(--accent);font-size:0.6rem;letter-spacing:0.08em;">CLAUDE ASSESSMENT</strong><br><br>${llmExplanationCache}`;
  } else {
    const explain = currentExplainMode === 'human' ? NERVA.explainHuman(result) : NERVA.explainAnalyst(result);
    document.getElementById('nl-explanation').innerHTML = explain;
  }

  // API output
  const json = NERVA.toJSON(result);
  const apiStr = JSON.stringify(json, null, 2);
  document.getElementById('api-output').innerHTML = apiStr
    .replace(/"([^"]+)":/g, '<span class="key">"$1"</span>:')
    .replace(/: "([^"]*?)"/g, ': <span class="string">"$1"</span>')
    .replace(/: (-?\d+\.?\d*)/g, ': <span class="number">$1</span>');

  // LLM schema
  document.getElementById('llm-schema').textContent = JSON.stringify(NERVA.toLLMSchema(result), null, 2);
}


// ═══════════════════════════════════════
//  EVENT BINDING
// ═══════════════════════════════════════

// Sliders
['e', 's', 'r', 'sup', 'stab'].forEach(k => {
  sliders[k].addEventListener('input', () => {
    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    llmExplanationCache = '';  // Clear LLM cache on manual slider change
    lastScenarioText = '';
    update();
  });
});
sliders.tau.addEventListener('input', update);

// Presets (no longer set tau — let tau mode handle it)
document.querySelectorAll('.preset-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const p = PRESETS[btn.dataset.preset];
    if (!p) return;
    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    sliders.e.value = p.e;
    sliders.s.value = p.s;
    sliders.r.value = p.r;
    sliders.sup.value = p.sup;
    sliders.stab.value = p.stab;
    // Clear NL input
    document.getElementById('nl-input').value = '';
    document.getElementById('nl-extracted').classList.remove('show');
    llmExplanationCache = '';
    lastScenarioText = '';
    trailPoints = [];
    update();
  });
});

// τ mode selector
document.querySelectorAll('.tau-mode-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.tau-mode-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentTauMode = btn.dataset.tau;
    document.getElementById('tau-desc').innerHTML = TAU_DESCRIPTIONS[currentTauMode];

    const wrap = document.getElementById('tau-slider-wrap');
    if (currentTauMode === 'manual') {
      wrap.classList.remove('disabled');
    } else {
      wrap.classList.add('disabled');
    }
    update();
  });
});

// Explain toggle
document.querySelectorAll('.explain-toggle-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.explain-toggle-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentExplainMode = btn.dataset.mode;
    update();
  });
});

// ─── LLM-POWERED EXTRACTION ───
let lastScenarioText = '';

async function extractViaLLM(scenario) {
  const resp = await fetch('/api/extract', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ scenario })
  });
  if (!resp.ok) throw new Error(await resp.text());
  return await resp.json();
}

async function explainViaLLM(scenario, inputs, nerva) {
  const resp = await fetch('/api/explain', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ scenario, inputs, nerva })
  });
  if (!resp.ok) throw new Error(await resp.text());
  return await resp.json();
}

// NL Evaluate
document.getElementById('eval-btn').addEventListener('click', async () => {
  const text = document.getElementById('nl-input').value.trim();
  if (!text) return;
  lastScenarioText = text;

  const btn = document.getElementById('eval-btn');
  const el = document.getElementById('nl-extracted');

  // Show loading state
  btn.disabled = true;
  btn.textContent = 'Extracting...';
  el.innerHTML = '<span style="color:var(--text-muted)">Calling Claude to analyze scenario...</span>';
  el.classList.add('show');

  try {
    // Try LLM extraction first
    const llmResult = await extractViaLLM(text);

    // Map LLM response to slider values
    const e = Math.max(0, Math.min(1, llmResult.urgency ?? 0.5));
    const s = Math.max(0, Math.min(1, llmResult.strategy ?? 0.5));
    const r = Math.max(0, Math.min(1, llmResult.risk ?? 0.5));
    const sup = Math.max(0, Math.min(1, llmResult.support ?? 0.5));
    const stab = Math.max(0, Math.min(1, llmResult.stability ?? 0.5));

    sliders.e.value = e;
    sliders.s.value = s;
    sliders.r.value = r;
    sliders.sup.value = sup;
    sliders.stab.value = stab;

    // Build extraction display
    const tags = [];
    if (e > 0.65) tags.push('urgency:high');
    else if (e < 0.35) tags.push('urgency:low');
    if (s > 0.65) tags.push('strategy:strong');
    else if (s < 0.35) tags.push('strategy:weak');
    if (r > 0.65) tags.push('risk:high');
    else if (r < 0.35) tags.push('risk:low');
    if (sup > 0.65) tags.push('evidence:strong');
    else if (sup < 0.35) tags.push('evidence:weak');
    if (stab > 0.65) tags.push('conditions:stable');
    else if (stab < 0.35) tags.push('conditions:unstable');

    // Show door type if available
    if (llmResult.irreversibility != null) {
      tags.push(llmResult.irreversibility > 0.6 ? 'one-way door' : 'two-way door');
    }

    el.innerHTML = '<span style="color:var(--accent)">✓ Claude extracted: </span>' +
      tags.map(t => `<span class="tag">${t}</span>`).join('') +
      (llmResult.reasoning ? `<br><span style="color:var(--text-muted);font-size:0.6rem;margin-top:0.3rem;display:inline-block;">${llmResult.reasoning}</span>` : '');
    el.classList.add('show');

  } catch (err) {
    // Fallback to client-side extraction
    console.warn('LLM extraction failed, falling back to local:', err);
    const result = NLExtractor.extract(text);
    sliders.e.value = result.e;
    sliders.s.value = result.s;
    sliders.r.value = result.r;
    sliders.sup.value = result.sup;
    sliders.stab.value = result.stab;

    if (result.tags.length > 0) {
      el.innerHTML = '<span style="color:var(--warn)">⚠ Local fallback: </span>' +
        result.tags.map(t => `<span class="tag">${t}</span>`).join('') +
        `<span style="color:var(--text-muted); margin-left:0.3rem;">(${result.confidence})</span>`;
    } else {
      el.innerHTML = '<span style="color:var(--text-muted)">No strong signals detected — using defaults.</span>';
    }
    el.classList.add('show');
  }

  btn.disabled = false;
  btn.textContent = 'Evaluate';

  document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
  trailPoints = [];
  update();

  // Now fetch LLM explanation asynchronously
  fetchLLMExplanation();
});

// LLM Explanation fetch (async, non-blocking)
let llmExplanationCache = '';

async function fetchLLMExplanation() {
  if (!lastScenarioText) return;

  const e = +sliders.e.value, s = +sliders.s.value, r = +sliders.r.value;
  const sup = +sliders.sup.value, stab = +sliders.stab.value;
  const tau = resolveTau();
  const result = NERVA.compute(e, s, r, sup, stab, tau);
  const json = NERVA.toJSON(result);

  try {
    const resp = await explainViaLLM(lastScenarioText, result.input, json);
    if (resp.explanation) {
      llmExplanationCache = resp.explanation;
      // If currently in human mode, update the display
      if (currentExplainMode === 'human') {
        document.getElementById('nl-explanation').innerHTML = `<strong style="color:var(--accent);font-size:0.6rem;letter-spacing:0.08em;">CLAUDE ASSESSMENT</strong><br><br>${resp.explanation}`;
      }
    }
  } catch (err) {
    console.warn('LLM explain failed, using local:', err);
    llmExplanationCache = '';
  }
}

// Enter key in textarea
document.getElementById('nl-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    document.getElementById('eval-btn').click();
  }
});

// Nav
document.querySelectorAll('.nav-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('view-' + btn.dataset.view).classList.add('active');
    if (btn.dataset.view === 'demo' && renderer) {
      const c = document.getElementById('three-canvas').parentElement;
      renderer.setSize(c.clientWidth, c.clientHeight);
      camera.aspect = c.clientWidth / c.clientHeight;
      camera.updateProjectionMatrix();
    }
  });
});

// Copy
document.getElementById('copy-btn').addEventListener('click', () => {
  const text = document.getElementById('api-output').textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById('copy-btn');
    btn.textContent = 'Copied';
    setTimeout(() => btn.textContent = 'Copy', 1500);
  });
});

// LLM toggle
document.getElementById('llm-toggle').addEventListener('click', () => {
  document.getElementById('llm-toggle').classList.toggle('open');
  document.getElementById('llm-content').classList.toggle('open');
});


// ═══════════════════════════════════════
//  INIT
// ═══════════════════════════════════════
initThree();
update();
</script>
</body>
</html>
